# 2.5 HTTP

## 2.5.1 HTTP/1.0

-   HTTP : 데이터를 주고 받을 수 있는 프로토콜
-   한 연결당 하나의 요청을 처리하도록 설계됨
-   RTT의 증가로 이어짐<br>
    **RTT** : 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 (패킷 왕복 시간)<br>
    **패킷** : 네트워크를 통해 전송되는 형식화된 데이터 덩어리
-   TCP의 3-way-handshake를 계속해서 열어야하기 때문에 RTT 증가

### RTT증가 해결 방법

-   **이미지 스플리팅**<br>
    많은 이미지를 다운로드 받으면 과부하가 걸리기 때문에 <br>이미지가 합쳐 있는 하나의 이미지를 다운로드하는 것
-   **코드 압축**<br>
    개행문자, 빈칸을 없애서 코드를 최소화
-   **이미지 Base64 인코딩**<br>
    이미지 파일을 64진법으로 이루어진 문자열로 인코딩<br>
    HTTP 요청을 할 필요가 없다는 장점<br>
    37%정도 크기가 증가하는 단점

## 2.5.2 HTTP/1.1

-   매번 TCP연결을 하는 것이 아니라 한 번 TCP 초기화를 한 후 keep-alive라는 옵션으로 여러개의 파일 송수신
-   한 번 TCP 3-way-handshake가 발생한 뒤 그 다음부터 발생하지 않는다.
-   요청할 리소스 개수에 비례해서 대기 시간이 길어지는 단점
-   **HOL Blocking(Head Of Line Blocking)**<br>
    요청을 여러개를 한꺼번에 보내도 응답은 첫 번째 요청의 응답부터 순차적으로 처리<br>
    같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
-   **무거운 헤더 구조**<br>
    쿠키 등 많은 메타데이터가 들어있고 압축이 되지 않아 무거움

## 2.5.3 HTTP/2

-   HTTP/1.x 보다 지연시간을 줄이고 응답시간이 더 빠름
-   멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원
-   **멀티플렉싱**<br>
    * 여러개의 스트림을 사용하여 송수신<br>

    스트림 : 일련의 데이터 요소를 가리키는 데이터 흐름<br>
    병렬로 여러 요청을 받을 수 있고 응답을 줄 수 있음 (HOL Blocking 해결)

    | Type | 특징 |
    |----------|--------------------|
    | HTTP/1.x   | 1, 2, 3 메시지를 받으면 순서대로 처리   |
    | HTTP/2   | 메시지를 여러개로 나누어 병렬적으로 처리   |
    * HTTP/2에서는 메시지를 여러개로 나누어 순서에 상관없이 보내도 반대편에서 해석하는데 문제가 없다. <br>(요청에 대한 응답을 받는 중 새로운 요청 프레임을 전송할 수도 있다.)

-   **헤더 압축**<br>
    * HTTP/1.x의 문제 중 큰 헤더<br>
    * 허프만 코딩 압축 알고리즘을 사용해 헤더 압축<br>
    **허프만 코딩** <br>
        효율적인 데이터 압축을 위해 사용하는 방법<br>
        빈도가 높은 정보는 적은 비트 수를 사용하여 표현, 빈도가 낮은 정보는 비트 수를 많이 사용해서 표현에 필요한 비트양을 줄이는 원리
-   **서버 푸시**<br>
    HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스 푸시<br>
    (HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일 다운로드)

## 2.5.4 HTTPS

-   애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 HTTP 요청
-   위 방법으로 통신을 암호화 한다.
-   **SSL/TLS**<br>
    전송 계층에서 보안을 제공하는 프로토콜<br>
    제 3자가 메시지를 도청하거나 변조하지 못하도록 함.<br>
    보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 사용
-   보안 세션<br>
    보안이 시작되고 끝나는 동안 유지되는 세션<br>
    SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성<br>
    **세션** : OS가 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간<br>
    클라이언트와 서버가 키를 공유하고 인증, 인증 확인 등의 작업이 일어나는 단 한 번의 1-RTT가 생긴 뒤 데이터를 송수신<br>
- **인증 메커니즘**<br>
    CA에서 발급한 인증서는 안전한 연결을 위해 필요한 '공개키'를 클라이언트에게 제공, 서버가 '신뢰 가능'하다는 것을 보증<br>
    - **공개키**<br>
        공개되어있는 키<br>
    - **개인키**<br>
        비밀키, 개인이 소유하고있는 키, 반드시 본인만 소유해야 함<br>
- **암호화 메커니즘**<br>
    디퍼-헬만(Diffie-Hellman) 방식으로 만들어졌다.<br>
    서로 만난적도, 본 적도 없는 두 사람이 서로를 믿을 수 있는 동일한 암호화 키를 가지게 해주는 알고리즘<br>
    $y = g^x\ mod\ p$<br>
    악의적인 공격자가 개인키, 공개키를 가지고도 PSK(pre Shared Key)가 없기 때문에 아무것도 할 수 없다.
- **해싱 알고리즘**<br>
    데이터를 추정하기 힘든 더 작고, 섞여있는 조각으로 만든 알고리즘<br>
    무슨 뜻인지 알아들을 수 없는 문자열로 변환

## 2.5.5 HTTP/3

-   QUIC이라는 계층 위에서 돌아감
-   TCP 기반이 아닌 UDP 기반
-   멀티플렉싱을 가지고 있으며 초기 연결 설정 시 지연시간 감소
- TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3-way-handshake 과정을 거치지 않음
-   TUIC은 첫 연결 설정에 1-RTT만 소요됨<br><br>

| 분류 | TCP | UDP |
|-----|-----|------|
| 정의 | 디바이스에서 웹 서버로 데이터를 전송하는 데이터 프로토콜 | 데이터를 데이터그램 단위로 처리하는 프로토콜|
|사용 범위 | 채팅, 이메일, 온라인 동영상, 웹검색 | 게임, 실시간 스트리밍 |
|특징 | 1. 운영체제와 독립적으로 작동, 시스템과 디바이스 간 상호 운용성 향상<br> 2. 데이터가 목적지에 도달했는지 확인하고 첫 번째 전송이 실패한 경우 재전송을 시도<br> 3. 전송중에 소량의 데이터라도 손실되면 TCP는 다른 정보를 로드하지 못할 수 있다.<br> 4. 높은 신뢰성<br> 5. 상대적으로 느리다.<br> 6. 3-way-handshakeing 과정을 통해 연결 설정, 4-way-handshaking을 통해 해제| 1. 더 작은 패킷을 더 작은 오버헤드로 전송하여 엔드투엔드 지연을 줄인다.<br> 2. 일부 패킷이 누락되더라도 데이터를 전송하므로 패킷 손실로 인해 전체 전송이 중단되지 않는다.<br> 3. 전송이 온전하게 도착한다고 보장할 수 없다. 일부 패킷이 손실되었을 수 있지만 발신자 측에서 이를 확인할 수 있는 방법이 없다.<br> 4. 낮은 신뢰성<br> 5. 상대적으로 빠르다.<br> 6. 정보를 주고 받을 때 신호절차를 거치지 않는다.|

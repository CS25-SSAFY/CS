# 2.5 HTTP

## 2.5.1 HTTP/1.0

-   한 연결당 하나의 요청을 처리하도록 설계됨
-   RTT의 증가로 이어짐<br>
    RTT : 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 (패킷 왕복 시간)<br>
    패킷 : 네트워크를 통해 전송되는 형식화된 데이터 덩어리
-   TCP의 3-way-handshake를 계속해서 열어야하기 때문에 RTT 증가

### RTT증가 해결 방법

-   이미지 스플리팅<br>
    많은 이미지를 다운로드 받으면 과부하가 걸리기 때문에 <br>이미지가 합쳐 있는 하나의 이미지를 다운로드하는 것f
-   코드 압축<br>
    개행문자, 빈칸을 없애서 코드를 최소화
-   이미지 Base64 인코딩<br>
    이미지 파일을 64진법으로 이루어진 문자열로 인코딩<br>
    HTTP 요청을 할 필요가 없다는 장점<br>
    37%정도 크기가 증가하는 단점

## 2.5.2 HTTP/1.1

-   매번 TCP연결을 하는 것이 아니라 한 번 TCP 초기화를 한 후 keep-alive라는 옵션으로 여러개의 파일 송수신
-   한 번 TCP 3-way-handshake가 발생한 뒤 그 다음부터 발생하지 않는다.
-   요청할 리소스 개수에 비례해서 대기 시간이 길어지는 단점
-   HOL Blocking(Head Of Line Blocking)<br>
    같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
-   무거운 헤더 구조<br>
    쿠키 등 많은 메타데이터가 들어있고 압축이 되지 않아 무거움

## 2.5.3 HTTP/2

-   HTTP/1.x 보다 지연시간을 줄이고 응답시간이 더 빠름
-   멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리 지원
-   멀티플렉싱<br>
    여러개의 스트림을 사용하여 송수신<br>
    스트림 : 일련의 데이터 요소를 가리키는 데이터 흐름<br>
    병렬로 여러 요청을 받을 수 있고 응답을 줄 수 있음 (HOL Blocking 해결)
-   헤더 압축<br>
    허프만 코딩 압축 알고리즘을 사용해 헤더 압축<br>
    허프만 코딩 : 빈도가 높은 정보는 적은 비트 수를 사용하여 표현, 빈도가 낮은 정보는 비트 수를 많이 사용해서 표현에 필요한 비트양을 줄이는 원리
-   서버 푸시<br>
    HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스 푸시<br>
    (HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일 다운로드)

## 2.5.4 HTTPS

-   애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 HTTP 요청
-   위 방법으로 통신을 암호화 한다.
-   SSL/TLS<br>
    전송 계층에서 보안을 제공하는 프로토콜<br>
    제 3자가 메시지를 도청하거나 변조하지 못하도록 함.<br>
    보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 사용
-   보안 세션
    보안이 시작되고 끝나는 동안 유지되는 세션<br>
    SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성<br>
    세션 : OS가 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간<br>
    클라이언트와 서버가 키를 공유하고 인증, 인증 확인 등의 작업이 일어나는 단 한 번의 1-RTT가 생긴 뒤 데이터를 송수신

## 2.5.5 HTTP/3

-   QUIC이라는 계층 위에서 돌아감, TCP 기반이 아닌 UDP 기반
-   멀티플렉싱을 가지고 있으며 초기 연결 설정 시 지연시간 감소<br>
    TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3-way-handshake 과정을 거치지 않음
-   TUIC은 첫 연결 설정에 1-RTT만 소요됨
